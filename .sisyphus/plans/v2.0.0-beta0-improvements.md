# Larch v2.0.0-beta0 Pre-Release Improvements

**Created**: 2026-01-11
**Status**: Ready for Implementation
**Estimated Effort**: ~6-7 hours

---

## Executive Summary

This plan addresses 6 improvements for Larch's 2.0.0-beta0 pre-release:

1. **Auth & Token Management** - Implement Taiga's JWT refresh flow
2. **Dashboard Enhancements** - Add date display with sorting
3. **User Profile UI** - Display actual user name and avatar
4. **Switch Component Bug Fix** - Resolve CSS conflict
5. **Assignee Selector Search** - Add filtering to member selection
6. **Version Bump** - Update to 2.0.0-beta.0

---

## Implementation Order

```
Phase 1: Foundation (No Dependencies)
├─ Task 6: Version Bump (independent, can do first)
├─ Task 4: Switch Fix (independent, quick win)
└─ Task 5: Assignee Search (independent, no dependencies)

Phase 2: Data Layer (Backend First)
└─ Task 2: Dashboard Dates
    ├─ 2.1: Update taiga-client DTOs
    ├─ 2.2: Update domain model
    └─ 2.4: Update TypeScript interfaces

Phase 3: Auth Layer (Most Complex)
└─ Task 1: Auth & Token Refresh
    ├─ 1.1: Update credentials service
    ├─ 1.2: Add refresh command
    ├─ 1.3: Update login command
    ├─ 1.4: Create API wrapper
    └─ 1.5: Update components

Phase 4: UI Enhancement (Depends on User Model)
└─ Task 3: User Profile
    ├─ 3.1: Create User interface
    ├─ 3.2: Create user store
    ├─ 3.3: Update App.svelte
    ├─ 3.4: Update LoginScreen
    └─ 3.5: Update Header
```

---

## Task 1: Auth & Token Management (JWT Refresh)

### Research Summary

- Taiga uses **JWT tokens** with 1-hour access token + 3-day refresh token
- **Token rotation**: Every refresh returns a new refresh token (old one invalidated)
- Requires storing both `auth_token` and `refresh` tokens in OS Keyring
- Refresh endpoint: `POST /api/v1/auth/refresh` with JSON body `{"refresh": "..."}`

### 1.1 Backend: Token Storage Enhancement

**File**: `src-tauri/src/services/credentials.rs`

Add new functions:

```rust
pub fn get_refresh_token() -> Result<Secret<String>> {
    let entry = Entry::new("larch-app", "taiga-refresh-token")?;
    let token = entry.get_password()?;
    Ok(Secret::new(token))
}

pub fn set_refresh_token(token: &str) -> Result<()> {
    let entry = Entry::new("larch-app", "taiga-refresh-token")?;
    entry.set_password(token)?;
    Ok(())
}

pub fn delete_refresh_token() -> Result<()> {
    let entry = Entry::new("larch-app", "taiga-refresh-token")?;
    entry.delete_credential().ok(); // Ignore if not exists
    Ok(())
}
```

### 1.2 Backend: Update taiga-client for Refresh

**File**: `crates/taiga-client/src/lib.rs`

Add refresh method:

```rust
pub async fn refresh(&self, refresh_token: &str) -> Result<RefreshResponse, TaigaClientError> {
    let url = format!("{}/api/v1/auth/refresh", self.base_url);
    let body = serde_json::json!({ "refresh": refresh_token });

    let response = self.client
        .post(&url)
        .json(&body)
        .send()
        .await?;

    if response.status() == StatusCode::UNAUTHORIZED {
        return Err(TaigaClientError::Unauthorized(response.status()));
    }

    let tokens: RefreshResponse = response.json().await?;
    Ok(tokens)
}
```

**File**: `crates/taiga-client/src/models.rs`

Add response struct:

```rust
#[derive(Debug, Deserialize)]
pub struct RefreshResponse {
    pub auth_token: String,
    pub refresh: String,
}
```

### 1.3 Backend: Add Refresh Command

**File**: `src-tauri/src/commands/auth_commands.rs`

```rust
#[tauri::command]
pub async fn refresh_token(
    client: tauri::State<'_, TaigaClient>,
) -> Result<()> {
    let refresh = credentials::get_refresh_token()?;
    let new_tokens = client.refresh(refresh.expose_secret()).await?;

    credentials::set_api_token(&new_tokens.auth_token)?;
    credentials::set_refresh_token(&new_tokens.refresh)?;

    Ok(())
}
```

Register in `src-tauri/src/lib.rs`:

```rust
.invoke_handler(tauri::generate_handler![
    // existing...
    auth_commands::refresh_token,
])
```

### 1.4 Backend: Update Login to Store Refresh Token

**File**: `src-tauri/src/commands/auth_commands.rs`

Modify `login` command to store refresh token from login response.

### 1.5 Backend: Update Logout to Clear Refresh Token

**File**: `src-tauri/src/commands/auth_commands.rs`

Modify `logout` command:

```rust
#[tauri::command]
pub async fn logout() -> Result<()> {
    credentials::delete_api_token()?;
    credentials::delete_refresh_token()?;
    Ok(())
}
```

### 1.6 Frontend: Add Command Constant

**File**: `src/lib/commands.svelte.ts`

```typescript
export const CMD_REFRESH_TOKEN = 'refresh_token';
```

### 1.7 Frontend: Create API Wrapper with Refresh Logic

**File**: `src/lib/services/api.ts` (NEW)

```typescript
import { invoke } from '@tauri-apps/api/core';
import { CMD_REFRESH_TOKEN } from '$lib/commands.svelte';
import { toast } from 'svelte-sonner';
import { t } from 'svelte-i18n';

let isRefreshing = false;
let refreshPromise: Promise<void> | null = null;
let onSessionExpired: (() => void) | null = null;

export function setSessionExpiredHandler(handler: () => void) {
	onSessionExpired = handler;
}

export async function apiCall<T>(command: string, args?: Record<string, unknown>): Promise<T> {
	try {
		return await invoke<T>(command, args);
	} catch (error: unknown) {
		const errorStr = String(error);

		// Check if 401/Unauthorized error
		if (errorStr.includes('Unauthorized') || errorStr.includes('401')) {
			// Attempt token refresh
			try {
				await handleTokenRefresh();
				// Retry original request
				return await invoke<T>(command, args);
			} catch {
				// Refresh failed - redirect to login
				handleSessionExpired();
				throw error;
			}
		}
		throw error;
	}
}

async function handleTokenRefresh(): Promise<void> {
	// If already refreshing, wait for that to complete
	if (isRefreshing && refreshPromise) {
		return refreshPromise;
	}

	isRefreshing = true;
	refreshPromise = invoke<void>(CMD_REFRESH_TOKEN);

	try {
		await refreshPromise;
	} finally {
		isRefreshing = false;
		refreshPromise = null;
	}
}

function handleSessionExpired(): void {
	toast.error('Session expired. Please log in again.');
	if (onSessionExpired) {
		onSessionExpired();
	}
}
```

### 1.8 Frontend: Integrate API Wrapper in App.svelte

**File**: `src/App.svelte`

```typescript
import { setSessionExpiredHandler } from '$lib/services/api';

onMount(() => {
	setSessionExpiredHandler(() => {
		currentScreen = 'login';
	});
	// ... existing validation
});
```

### Testing Checklist

- [ ] Verify both tokens are stored after login
- [ ] Test token refresh (mock 401 response)
- [ ] Verify redirect to login on refresh failure
- [ ] Test concurrent 401 requests (only one refresh)
- [ ] Verify logout clears both tokens
- [ ] Test toast notification appears on session expiry

---

## Task 2: Dashboard Date Display & Sorting

### 2.1 Update taiga-client DTOs

**File**: `crates/taiga-client/src/models.rs`

Add to `ProjectDto` and `ProjectListEntryDto`:

```rust
pub struct ProjectDto {
    // existing fields...
    pub created_date: Option<String>,
    pub modified_date: Option<String>,
}

pub struct ProjectListEntryDto {
    // existing fields...
    pub created_date: Option<String>,
    pub modified_date: Option<String>,
}
```

### 2.2 Update Domain Model

**File**: `src-tauri/src/domain/project.rs`

```rust
#[derive(Debug, Clone, Serialize)]
pub struct Project {
    pub id: i64,
    pub name: String,
    pub slug: String,
    pub description: String,
    pub owner: i64,
    pub created_date: Option<String>,
    pub modified_date: Option<String>,
}

impl From<ProjectDto> for Project {
    fn from(dto: ProjectDto) -> Self {
        Self {
            id: dto.id,
            name: dto.name,
            slug: dto.slug,
            description: dto.description.unwrap_or_default(),
            owner: dto.owner,
            created_date: dto.created_date,
            modified_date: dto.modified_date,
        }
    }
}
```

### 2.3 Update TypeScript Interface

**File**: `src/lib/types.ts`

```typescript
export interface Project {
	id: number;
	name: string;
	slug: string;
	description: string;
	owner: number;
	created_date: string | null;
	modified_date: string | null;
}
```

### 2.4 Update Dashboard with Sorting

**File**: `src/lib/screens/DashboardScreen.svelte`

```typescript
// Add sorting logic
let sortedProjects = $derived(
	[...projects].sort((a, b) => {
		const dateA = a.modified_date ?? a.created_date ?? '';
		const dateB = b.modified_date ?? b.created_date ?? '';
		return dateB.localeCompare(dateA); // Descending (newest first)
	})
);

// Helper for display
function formatDate(project: Project): string {
	const date = project.modified_date ?? project.created_date;
	if (!date) return $t('dashboard.noDate');
	return new Date(date).toLocaleDateString();
}
```

### 2.5 Add Translation Keys

**File**: `src/lib/locales/en.json`

```json
{
	"dashboard": {
		"lastModified": "Last Modified",
		"noDate": "No date"
	}
}
```

### Testing Checklist

- [ ] Verify date fields are fetched from Taiga API
- [ ] Test fallback logic when `modified_date` is null
- [ ] Verify default sorting (newest first)
- [ ] Check date formatting in different locales

---

## Task 3: User Profile UI Enhancement

### 3.1 Create User Interface

**File**: `src/lib/types.ts`

```typescript
export interface User {
	id: number;
	username: string;
	full_name: string;
	email: string;
	photo: string | null;
	big_photo: string | null;
	gravatar_id: string;
	is_active: boolean;
}
```

### 3.2 Create Global User Store

**File**: `src/lib/stores/user.svelte.ts` (NEW)

```typescript
import type { User } from '$lib/types';

let user = $state<User | null>(null);

export function getCurrentUser(): User | null {
	return user;
}

export function setCurrentUser(newUser: User | null): void {
	user = newUser;
}

export function clearCurrentUser(): void {
	user = null;
}

// Export reactive getter for components
export function useCurrentUser() {
	return {
		get value() {
			return user;
		}
	};
}
```

### 3.3 Update App.svelte

**File**: `src/App.svelte`

```typescript
import { setCurrentUser, clearCurrentUser } from '$lib/stores/user.svelte';

async function validateSession() {
	try {
		const user = await invoke<User>(CMD_GET_ME);
		setCurrentUser(user);
		currentScreen = 'dashboard';
	} catch {
		clearCurrentUser();
		currentScreen = 'login';
	}
}
```

### 3.4 Update Login Screen

**File**: `src/lib/screens/LoginScreen.svelte`

After successful login, store user:

```typescript
import { setCurrentUser } from '$lib/stores/user.svelte';

async function handleLogin() {
	// ... existing login logic
	const user = await invoke<User>(CMD_GET_ME);
	setCurrentUser(user);
}
```

### 3.5 Update Header Component

**File**: `src/lib/components/layout/Header.svelte`

```svelte
<script lang="ts">
	import { useCurrentUser } from '$lib/stores/user.svelte';
	import { t } from 'svelte-i18n';

	const currentUser = useCurrentUser();

	let displayName = $derived(
		currentUser.value?.full_name || currentUser.value?.username || $t('header.user')
	);

	let avatarUrl = $derived(currentUser.value?.photo || currentUser.value?.big_photo || null);

	let initials = $derived(displayName.charAt(0).toUpperCase());
</script>

<div class="flex items-center gap-2">
	{#if avatarUrl}
		<img src={avatarUrl} alt={displayName} class="h-8 w-8 rounded-full object-cover" />
	{:else}
		<div
			class="bg-primary text-primary-foreground flex h-8 w-8 items-center justify-center rounded-full text-sm font-medium"
		>
			{initials}
		</div>
	{/if}
	<span class="text-sm">{displayName}</span>
</div>
```

### Testing Checklist

- [ ] Verify user data is loaded after login
- [ ] Test with user that has `full_name`
- [ ] Test with user that only has `username`
- [ ] Verify photo avatar displays correctly
- [ ] Test fallback to initial letter avatar

---

## Task 4: Switch Component Bug Fix

### 4.1 Remove Global CSS Overrides

**File**: `src/app.css`

Remove lines ~153-182 containing "Stitch Toggle Switch Override" with `!important` rules.

Look for and DELETE:

```css
/* Stitch Toggle Switch Override */
[data-slot="switch"] { ... }
[data-slot="switch"] [data-slot="thumb"] { ... }
/* etc. */
```

### 4.2 Verify Switch Component Styling

**File**: `src/lib/components/ui/switch/switch.svelte`

Ensure it uses standard shadcn-svelte classes without conflicts:

```svelte
<!-- Default shadcn-svelte styling should work after removing overrides -->
<Switch.Root
	class="peer focus-visible:ring-ring focus-visible:ring-offset-background data-[state=checked]:bg-primary data-[state=unchecked]:bg-input inline-flex h-5 w-9 shrink-0 cursor-pointer items-center rounded-full border-2 border-transparent shadow-sm transition-colors focus-visible:ring-2 focus-visible:ring-offset-2 focus-visible:outline-none disabled:cursor-not-allowed disabled:opacity-50"
	{...$$restProps}
>
	<Switch.Thumb
		class="bg-background pointer-events-none block h-4 w-4 rounded-full shadow-lg ring-0 transition-transform data-[state=checked]:translate-x-4 data-[state=unchecked]:translate-x-0"
	/>
</Switch.Root>
```

### Testing Checklist

- [ ] Verify switch displays correctly in active state
- [ ] Test dark mode styling
- [ ] Test alignment in project configuration list
- [ ] Verify toggle animation is smooth

---

## Task 5: Assignee Selector Search

### 5.1 Update Metadata Sidebar

**File**: `src/lib/components/issue-detail/IssueMetadataSidebar.svelte`

Add search functionality:

```svelte
<script lang="ts">
	import { Input } from '$lib/components/ui/input';
	import * as Select from '$lib/components/ui/select';
	import { t } from 'svelte-i18n';

	let { members, assignedTo, onAssigneeChange } = $props();

	let searchQuery = $state('');

	let filteredMembers = $derived(() => {
		if (!searchQuery.trim()) return members;

		const query = searchQuery.toLowerCase().trim();
		return members.filter(
			(m: Member) =>
				m.full_name?.toLowerCase().includes(query) || m.username?.toLowerCase().includes(query)
		);
	});
</script>

<div class="space-y-2">
	<label class="text-sm font-medium">{$t('issue.assignee')}</label>

	<Input
		type="text"
		placeholder={$t('assignee.searchPlaceholder')}
		bind:value={searchQuery}
		class="h-8 text-sm"
	/>

	<Select.Root value={assignedTo?.toString() ?? ''} onValueChange={onAssigneeChange}>
		<Select.Trigger class="w-full">
			<Select.Value placeholder={$t('assignee.unassigned')} />
		</Select.Trigger>
		<Select.Content>
			<Select.Item value="">{$t('assignee.unassigned')}</Select.Item>
			{#each filteredMembers as member}
				<Select.Item value={member.id.toString()}>
					{member.full_name || member.username}
				</Select.Item>
			{/each}
		</Select.Content>
	</Select.Root>
</div>
```

### 5.2 Add Translation Keys

**File**: `src/lib/locales/en.json`

```json
{
	"assignee": {
		"searchPlaceholder": "Search members...",
		"unassigned": "Unassigned"
	}
}
```

### Testing Checklist

- [ ] Test search with full name match
- [ ] Test search with username match
- [ ] Test case-insensitive search
- [ ] Verify empty search shows all members
- [ ] Test with large member lists

---

## Task 6: Version Bump to 2.0.0-beta.0

### 6.1 Update package.json

**File**: `package.json`

```json
{
	"version": "2.0.0-beta.0"
}
```

### 6.2 Update tauri.conf.json

**File**: `src-tauri/tauri.conf.json`

```json
{
	"version": "2.0.0-beta.0"
}
```

### 6.3 Update Cargo.toml

**File**: `src-tauri/Cargo.toml`

```toml
[package]
version = "2.0.0-beta.0"
```

### 6.4 Add Version Bump Task to Justfile

**File**: `Justfile`

```makefile
# Bump version across all config files
# Usage: just bump 2.0.0-beta.1
bump version:
    @echo "Bumping version to {{version}}..."
    sed -i 's/"version": "[^"]*"/"version": "{{version}}"/' package.json
    sed -i 's/"version": "[^"]*"/"version": "{{version}}"/' src-tauri/tauri.conf.json
    sed -i 's/^version = "[^"]*"/version = "{{version}}"/' src-tauri/Cargo.toml
    @echo "Version bumped to {{version}}"
    @echo "Don't forget to: git tag -a v{{version}} -m 'Release v{{version}}'"
```

### 6.5 Update AGENTS.md

**File**: `AGENTS.md`

Add to Quick Reference section:

```markdown
just bump <version> # Bump version (e.g., just bump 2.0.0-beta.1)
```

### 6.6 Create Git Tag (Manual Step)

```bash
git tag -a v2.0.0-beta.0 -m "Release v2.0.0-beta.0"
git push origin v2.0.0-beta.0
```

### Testing Checklist

- [ ] Verify all three config files show same version
- [ ] Test `just bump` command
- [ ] Verify Git tag created successfully

---

## Success Criteria

- [ ] Token refresh works seamlessly without user interruption
- [ ] Dashboard shows "Last Modified" date and sorts by it
- [ ] Header displays actual user name and avatar
- [ ] Project activation switches display correctly in all states
- [ ] Assignee selector has functional search
- [ ] Version 2.0.0-beta.0 committed and tagged
- [ ] All tests pass (`just test`)
- [ ] All checks pass (`just check`)
- [ ] Documentation updated (AGENTS.md)

---

## Risks & Mitigations

| Risk                               | Impact | Mitigation                                    |
| ---------------------------------- | ------ | --------------------------------------------- |
| Token refresh concurrency issues   | High   | Use semaphore flag, queue concurrent requests |
| Taiga API token rotation confusion | Medium | Clear documentation, thorough testing         |
| Switch component size regression   | Low    | Test in both light and dark modes             |
| Date sorting with null values      | Low    | Fallback logic already planned                |
| User store initialization timing   | Low    | Test cold-start login flow                    |
